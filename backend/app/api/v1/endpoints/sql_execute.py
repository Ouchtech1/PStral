"""
SQL Execution endpoint for Pstral.
Allows users to execute SQL queries generated by the AI.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import logging

from ....core.auth import User, get_current_active_user
from ....infrastructure.database.oracle_client import db_client
from ....infrastructure.database.audit_db import log_action
from ....core.security import filter_sql_prompt

logger = logging.getLogger(__name__)

router = APIRouter()


class SQLExecuteRequest(BaseModel):
    query: str
    max_rows: int = 100


class SQLExecuteResponse(BaseModel):
    success: bool
    columns: List[str]
    rows: List[Dict[str, Any]]
    row_count: int
    error: Optional[str] = None
    warning: Optional[str] = None


class SQLValidateRequest(BaseModel):
    query: str


class SQLValidateResponse(BaseModel):
    valid: bool
    query_type: str
    message: str


# List of dangerous keywords that should not be allowed
DANGEROUS_KEYWORDS = [
    "DROP", "DELETE", "TRUNCATE", "ALTER", "CREATE", "INSERT", "UPDATE",
    "GRANT", "REVOKE", "EXEC", "EXECUTE", "CALL", "MERGE"
]


def validate_query(query: str) -> tuple[bool, str, str]:
    """
    Validate a SQL query for safety.
    Returns: (is_valid, query_type, message)
    """
    query_upper = query.strip().upper()
    
    # Check for dangerous keywords
    for keyword in DANGEROUS_KEYWORDS:
        if query_upper.startswith(keyword) or f" {keyword} " in f" {query_upper} ":
            return False, keyword, f"Les requêtes {keyword} ne sont pas autorisées pour des raisons de sécurité."
    
    # Only allow SELECT queries
    if not query_upper.startswith("SELECT"):
        return False, "UNKNOWN", "Seules les requêtes SELECT sont autorisées."
    
    # Additional security filters
    filtered, reason = filter_sql_prompt(query)
    if filtered != query:
        return False, "FILTERED", reason or "La requête contient des éléments non autorisés."
    
    return True, "SELECT", "Requête valide"


@router.post("/validate", response_model=SQLValidateResponse)
async def validate_sql(
    request: SQLValidateRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Validate a SQL query without executing it.
    """
    is_valid, query_type, message = validate_query(request.query)
    return SQLValidateResponse(
        valid=is_valid,
        query_type=query_type,
        message=message
    )


@router.post("/execute", response_model=SQLExecuteResponse)
async def execute_sql(
    request: SQLExecuteRequest,
    current_user: User = Depends(get_current_active_user)
):
    """
    Execute a SQL query and return results.
    Only SELECT queries are allowed for security.
    """
    # Validate the query
    is_valid, query_type, message = validate_query(request.query)
    
    if not is_valid:
        log_action(
            user_id=current_user.id,
            username=current_user.username,
            action="SQL_EXECUTE_BLOCKED",
            resource="/api/v1/sql/execute",
            details={"query": request.query[:500], "reason": message},
            status="error"
        )
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=message
        )
    
    # Check if database is connected
    if not db_client.pool:
        # Return mock data for demo/testing
        log_action(
            user_id=current_user.id,
            username=current_user.username,
            action="SQL_EXECUTE_MOCK",
            resource="/api/v1/sql/execute",
            details={"query": request.query[:500]},
            status="success"
        )
        return SQLExecuteResponse(
            success=True,
            columns=["info"],
            rows=[{"info": "Base de données Oracle non connectée. Mode démo activé."}],
            row_count=1,
            warning="Base de données non disponible - résultats de démonstration"
        )
    
    try:
        # Execute the query
        async with db_client.pool.acquire() as connection:
            async with connection.cursor() as cursor:
                await cursor.execute(request.query)
                
                # Get column names
                columns = [desc[0] for desc in cursor.description] if cursor.description else []
                
                # Fetch rows with limit
                rows_raw = await cursor.fetchmany(request.max_rows)
                
                # Convert to list of dicts
                rows = []
                for row in rows_raw:
                    row_dict = {}
                    for i, col in enumerate(columns):
                        value = row[i]
                        # Convert non-serializable types to strings
                        if value is not None and not isinstance(value, (str, int, float, bool)):
                            value = str(value)
                        row_dict[col] = value
                    rows.append(row_dict)
                
                # Log successful execution
                log_action(
                    user_id=current_user.id,
                    username=current_user.username,
                    action="SQL_EXECUTE_SUCCESS",
                    resource="/api/v1/sql/execute",
                    details={"query": request.query[:500], "rows_returned": len(rows)},
                    status="success"
                )
                
                return SQLExecuteResponse(
                    success=True,
                    columns=columns,
                    rows=rows,
                    row_count=len(rows)
                )
                
    except Exception as e:
        logger.error(f"SQL execution error: {e}")
        
        log_action(
            user_id=current_user.id,
            username=current_user.username,
            action="SQL_EXECUTE_ERROR",
            resource="/api/v1/sql/execute",
            details={"query": request.query[:500], "error": str(e)[:500]},
            status="error"
        )
        
        return SQLExecuteResponse(
            success=False,
            columns=[],
            rows=[],
            row_count=0,
            error=f"Erreur d'exécution: {str(e)}"
        )

